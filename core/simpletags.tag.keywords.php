<?php
// Option: meta_always_include, meta_keywords_qty

Class SimpleTags_Keyword {
	var $options = array();
	
	// Stock Post ID for current view
	var $posts = array();
	var $tags_currentposts = array();
	
	function SimpleTags_Keywords() {
		// Load default options
		$this->options = array(
			'meta_always_include' => '',
			'meta_keywords_qty' => 0
		);
		
		// Stock Posts ID (useful for autolink and metakeywords)
		add_filter( 'the_posts', array(&$this, 'getPostIds') );
		
		// Add keywords to header
		if ( !class_exists('All_in_One_SEO_Pack') ) {
			add_action('wp_head', array(&$this, 'outputMetaKeywords'));
		}
	}
	
	/**
	 * Stock posts ID as soon as possible
	 *
	 * @param array $posts
	 * @return array
	 */
	function getPostIds( $posts ) {
		if ( !empty($posts) && is_array($posts) ) {
			foreach( (array) $posts as $post) {
				if ( ((int) $post->ID) != 0 ) {
					$this->posts[] = (int) $post->ID;
				}
			}
		}
		return $posts;
	}

	/**
	 * Get tags from current post views
	 *
	 * @return boolean
	 */
	function getTagsFromCurrentPosts() {
		if ( is_array($this->posts) && count($this->posts) > 0 ) {
			// Generate SQL from post id
			$postlist = implode( "', '", $this->posts );

			global $wp_object_cache;
			if ( $wp_object_cache->cache_enabled === true ) { // Use cache
				// Generate key cache
				$key = md5(maybe_serialize($postlist));
				// Get cache if exist
				$cache = wp_cache_get( 'generate_keywords', 'simpletags' );
				if ( $cache ) {
					if ( isset( $cache[$key] ) ) {
						$this->tags_currentposts = $cache[$key];
						return true;
					}
				}
			}

			// If cache not exist, get datas and set cache
			global $wpdb;
			$this->tags_currentposts = $wpdb->get_results("
				SELECT t.name AS name, t.term_id AS term_id, tt.count AS count
				FROM {$wpdb->term_relationships} AS tr
				INNER JOIN {$wpdb->term_taxonomy} AS tt ON (tr.term_taxonomy_id = tt.term_taxonomy_id)
				INNER JOIN {$wpdb->terms} AS t ON (tt.term_id = t.term_id)
				WHERE tt.taxonomy = 'post_tag'
				AND tr.object_id.ID IN ('{$postlist}')
				GROUP BY t.term_id
				ORDER BY tt.count DESC");

			if ( $wp_object_cache->cache_enabled === true ) { // Use cache
				$cache[$key] = $this->tags_currentposts;
				wp_cache_set('generate_keywords', $cache, 'simpletags');
			}

			unset($key);
			return true;
		}
		return false;
	}

	/**
	 * Generate keywords for meta data
	 *
	 * @return string
	 */
	function generateKeywords() {
		// Get tags for current posts
		if ( empty($this->tags_currentposts) ) {
			$this->getTagsFromCurrentPosts();
		}

		$results = array();
		foreach ( (array) $this->tags_currentposts as $term ) {
			$results[] = stripslashes($term->name);
		}
		unset($this->tags_currentposts);

		$always_list = trim($this->options['meta_always_include']); // Static keywords
		$always_array = (array) explode(',', $always_list);

		// Trim
		foreach ( $always_array as $keyword ) {
			if ( empty($keyword) ) {
				continue;
			}
			$results[] = trim($keyword);
		}
		unset($always_list, $always_array);

		// Unique keywords
		$results = array_unique($results);

		// Return if empty
		if ( empty($results) ) {
			return '';
		}

		// Limit to max quantity if set
		$number = (int) $this->options['meta_keywords_qty'];
		if ( $number != 0 && is_array($results) && !empty($results) && count($results) > 1 ) {
			shuffle($results); // Randomize keywords
			$results = array_slice( $results, 0, $number );
		}

		return strip_tags(implode(', ', $results));
	}

	/**
	 * Display meta keywords
	 *
	 */
	function outputMetaKeywords() {
		$terms_list = $this->generateKeywords();
		if ( !empty($terms_list) ) {
			echo "\n\t" . '<!-- Generated by Simple Tags ' . $this->version . ' - http://wordpress.org/extend/plugins/simple-tags -->' 
				."\n\t" . '<meta name="keywords" content="' . $terms_list . '" />' . "\n";
			return true;
		}
		return false;
	}
}
?>